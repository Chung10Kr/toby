
토비의 스프링 6장 드럽게 어렵던데

잊을만 하면 다시 읽어보려고 개인저장용

# Aop란 무엇인가?

비즈니스 로직을 담은 UserService에 트랜잭션을 적용해온 과정을 정리해보자.

## 트랜잭션 서비스 추상화

dao단위의 트랜잭션을 service단위로 변경하기 위해서
비즈니스 로직과, 트랜잭션 경계설정 코드가 함께있는 코드를 작성하니
특정 트랜잭션에 기술이 종속되는 코드가 되어 버리는 문제가 발생했다.

- JDBC를 사용할때는 로컬 태랜잭션 방식을 적용한 코드
- JTA를 사용할때는 글로벌/분산 트랜잭션 방식을 적용한 코드

등 어떤것을 사용하느냐에 따라 트랜잭션 적용 코드를 수정해야 하는 일이 생겼다.

그렇기에 트랜잭션과 직접 관련이 없는 코드가 담긴 많은 클래스를 일일이 수정해야 했다.

=> 서비스 추상화 기법 적용

트랜잭션 적용이라는 추상적인 작업 내용은 유지한채로 구현 방법을 자유롭게 바꿀 수 있게 하고
구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시 다이내믹하게 DI를 활용하여 의존성을 주입해주었다.

=> 트랜잭션 방식이 변경해도 비즈니스 로직 코드는 영향을 주지 않음

## 프록시, 데코레이터 패턴

어떻게 트랜잭션을 처리할지는 추상화를 통해 코드에서 제거했지만,
여전히 비즈니스 로직 코드에서의 트랜잭션을 적용하는 코드는 분리하지 못함

=> 문제는 트랜잭션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다는점
=> 트랜잭션의 코드의 특성 때문에 메소드 추출로 제거할 수 없음

무슨말이냐

```java
try{
    //트랜잭션 시작
    //dao.updateUser();
    //트랜잭션 commit
}catch(){
    //트랜잭션 롤백
}
```
=> DI를 이요한 데코레이터 패턴 적용으로 해결 가능

클라이언트 -> 프록시 -> 타킷
클라이언트 -> 트랜잭션코드 -> 비즈니스로직코드

트랜잭션을 처리하는 코드는 일종에 데코레이터에 담겨서, 클라이언트와 비즈니스 로직을 담은 다킷 클래스 사이에 존재하도록 함

클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타킷의 접근할 수 있게 함.

=> 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고 독립적으로 로직을 검증할수 있는 고립된 단위 테스트를 만들 수도 있게 됐다.

